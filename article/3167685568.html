<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5"><meta name="description" content="统计留存率之前先弄清一下留存率的概念，百度百科中是这么说的：用户在某段时间内开始使用应用，经过一段时间后，仍然继续使用应用的被认作是留存；这部分用户占当时新增用户的比例即是留存率，会按照每隔1单位时 间（例日、周、月）来进行统计。顾名思义，留存指的就是“有多少用户留下来了”。留存用户和留存率体现了应用的质量和保留用户的能力。简单点说，第一天新增加了100个用户，第二天这100个人有50个还有登录，"><meta property="og:type" content="article"><meta property="og:title" content="位运算实现用户留存率"><meta property="og:url" content="https://panda843.github.io/article/3167685568.html"><meta property="og:site_name" content="是潘达呀"><meta property="og:description" content="统计留存率之前先弄清一下留存率的概念，百度百科中是这么说的：用户在某段时间内开始使用应用，经过一段时间后，仍然继续使用应用的被认作是留存；这部分用户占当时新增用户的比例即是留存率，会按照每隔1单位时 间（例日、周、月）来进行统计。顾名思义，留存指的就是“有多少用户留下来了”。留存用户和留存率体现了应用的质量和保留用户的能力。简单点说，第一天新增加了100个用户，第二天这100个人有50个还有登录，"><meta property="og:locale"><meta property="og:image" content="https://panda843.github.io/article/3167685568/3167685568/93d58b1b8cb950e860d514b6f4e19ff6.jpg"><meta property="article:published_time" content="2017-12-28T12:37:00.000Z"><meta property="article:modified_time" content="2024-02-28T09:27:30.066Z"><meta property="article:author" content="是潘达呀"><meta property="article:tag" content="PHP"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://panda843.github.io/article/3167685568/3167685568/93d58b1b8cb950e860d514b6f4e19ff6.jpg"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><title>位运算实现用户留存率</title><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/true" title="是潘达呀" type="application/atom+xml"><meta name="generator" content="Hexo 7.1.1"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a><a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a><a id="top-icon-tablet" href="#" aria-label="Top" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa-solid fa-chevron-up fa-lg"></i></a><span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="/tags/">Tags</a></li><li><a href="/about/">About</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" aria-label="Previous post" href="/article/4261225024.html"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" aria-label="Next post" href="/article/1832317452.html"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" aria-label="Back to top" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">Previous post</span> <span id="i-next" class="info" style="display:none">Next post</span> <span id="i-top" class="info" style="display:none">Back to top</span> <span id="i-share" class="info" style="display:none">Share post</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://panda843.github.io/article/3167685568.html"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https://panda843.github.io/article/3167685568.html&text=位运算实现用户留存率"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://panda843.github.io/article/3167685568.html&is_video=false&description=位运算实现用户留存率"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=位运算实现用户留存率&body=Check out this article: https://panda843.github.io/article/3167685568.html"><i class="fa-solid fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.tumblr.com/share/link?url=https://panda843.github.io/article/3167685568.html&name=位运算实现用户留存率&description=&lt;p&gt;统计留存率之前先弄清一下留存率的概念，百度百科中是这么说的：&lt;br&gt;用户在某段时间内开始使用应用，经过一段时间后，仍然继续使用应用的被认作是留存；这部分用户占当时新增用户的比例即是留存率，会按照每隔1单位时 间（例日、周、月）来进行统计。顾名思义，留存指的就是“有多少用户留下来了”。留存用户和留存率体现了应用的质量和保留用户的能力。&lt;br&gt;简单点说，第一天新增加了100个用户，第二天这100个人有50个还有登录，第三天这100个人还有30个有登录。。。依次类推&lt;br&gt;那次日留存率为50%，三日留存为30% 。&lt;br&gt;在统计系统中经常需要统计用户留存率，这里整理下用户留存率统计的几种实现方式。&lt;/p&gt;"><i class="fab fa-tumblr" aria-hidden="true"></i></a></li><li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://panda843.github.io/article/3167685568.html&t=位运算实现用户留存率"><i class="fab fa-hacker-news" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%9C%80%E5%90%8E%E7%99%BB%E5%BD%95%E6%97%B6%E9%97%B4%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">通过最后登录时间实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BB%BA%E7%AB%8B%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">通过建立独立的字段实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">通过位运算实现</span></a></li></ol></div></span></div><div class="content index py4"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle p-name" itemprop="name headline">位运算实现用户留存率</h1><div class="meta"><span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-name" itemprop="name">DuanEnJian</span></span><div class="postdate"><time datetime="2017-12-28T12:37:00.000Z" class="dt-published" itemprop="datePublished">2017-12-28</time></div><div class="article-category"><i class="fa-solid fa-archive"></i> <a class="category-link" href="/categories/develop/">开发</a></div><div class="article-tag"><i class="fa-solid fa-tag"></i> <a class="p-category" href="/tags/PHP/" rel="tag">PHP</a></div></div></header><div class="content e-content" itemprop="articleBody"><p>统计留存率之前先弄清一下留存率的概念，百度百科中是这么说的：<br>用户在某段时间内开始使用应用，经过一段时间后，仍然继续使用应用的被认作是留存；这部分用户占当时新增用户的比例即是留存率，会按照每隔1单位时 间（例日、周、月）来进行统计。顾名思义，留存指的就是“有多少用户留下来了”。留存用户和留存率体现了应用的质量和保留用户的能力。<br>简单点说，第一天新增加了100个用户，第二天这100个人有50个还有登录，第三天这100个人还有30个有登录。。。依次类推<br>那次日留存率为50%，三日留存为30% 。<br>在统计系统中经常需要统计用户留存率，这里整理下用户留存率统计的几种实现方式。</p><span id="more"></span><h1 id="通过最后登录时间实现"><a href="#通过最后登录时间实现" class="headerlink" title="通过最后登录时间实现"></a>通过最后登录时间实现</h1><p>有一张唯一表来记录新增用户，这张表至少包含这三个字段: uid, reg_time, last_visited_time。用户每次访问后更新最后访问时间（last_visited_time），假设3.6号新注册100个用户，需要统 计次日留存，则在3.8号凌晨统计reg_time为3.6并且last_visited_time为3.7号即可，参考SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> TBL_NAME <span class="keyword">WHERE</span> <span class="type">DATE</span>(reg_time) <span class="operator">=</span> <span class="string">&#x27;2014-03-06&#x27;</span> <span class="keyword">AND</span> <span class="type">DATE</span>(last_visited_time) <span class="operator">=</span> <span class="string">&#x27;2014-03-07&#x27;</span></span><br></pre></td></tr></table></figure><p>实现起来很简单，但问题也很明显，如果恰好这些用户0点有访问，且先一步更新了访问时间，留存率则记录不到了，这个对整个的结果偏差不会太大，先忽 略。有一个更明显的问题就是无法重复统计，如果脚本出错或者需要重新统计则无法实现。当然好处也有，就是统计方便，同时也方便新增N日留存。</p><h1 id="通过建立独立的字段实现"><a href="#通过建立独立的字段实现" class="headerlink" title="通过建立独立的字段实现"></a>通过建立独立的字段实现</h1><p>独立的字段可以这么设计，uid,reg_time,day_2,day_3,day_4…等等，当用户第二天有访问时更新day_2的字段为1，第三日访问更新day_3为1，该系列字段默认为0。同样的统计次日留存，则SQL应该是这样子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> TBL_NAME <span class="keyword">WHERE</span> <span class="type">DATE</span>(reg_time) <span class="operator">=</span> <span class="string">&#x27;2014-03-06&#x27;</span> <span class="keyword">AND</span> day_2 <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>该方法可以重复统计了，但又不方便扩展了，如果当前没有考虑到15天流程，则需要修改表结构，新增day_15才行。</p><h1 id="通过位运算实现"><a href="#通过位运算实现" class="headerlink" title="通过位运算实现"></a>通过位运算实现</h1><p>上面的数据表中记录的值就是很多的0和1，可以用这些二进制的0和1来表示当天是否有访问过，1表示有访问过，0表示未访问过。设计表中有这几个字段，uid,reg_time,retension,假设留存用retention记录，则<br>第一天访问 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 对应十进制的1，retention记录为1<br>第二天访问 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 第二天有访问后retention更新为3<br>第四天访问 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 第三天没有访问，第四天访问后rentention更新为11<br>依次类推，接下来就是计算该天的留存，以次日留存为例。将次日的数据与第2位为1其他位为0的值做按位与操作<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1<br>&amp;<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0<br>&#x3D;<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0<br>按位与是将都为1的设置为1，如果用整数来表示，求次日留存是 3 &amp; 2 ，如果结果为2则表示次日有访问过，如果不为2结果为0则说明没有访问过。所以求第N天的sql应该是（N表示第N天留存，如第3天用第3位来表示就是2的2次方）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM TBL_NAME WHERE DATE(reg_time) = &#x27;XXXX-XX-XX&#x27; AND retention &amp; 2^(N-1)</span><br></pre></td></tr></table></figure><p>当然这里的第几天实际表示第几日留存可以自己定，如果第10位表示30日留存，则将retention与2^9求按位与即可求得30日留存。<br>这里解决了读的问题，还有写的问题，首次注册时值为0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 ,第二天有访问则将前一天的值与第二位为1其他位为0的做按位或操作即可，按位或是将其中任何一个为 1 的位设为 1<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1<br>|<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0<br>&#x3D;<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1<br>第三天没有访问，第四天访问则是<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1<br>|<br>0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0<br>&#x3D;<br>0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1<br>用SQL来表示就是(N表示第N天访问)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE TBL_NAME SET retention = retention | 2^(N-1) WHERE uid = &#x27;XX&#x27;</span><br></pre></td></tr></table></figure><p>而且该更新操作在当天是可以重复操作的，因为按位或只需要有一个为1即可，第2天第一次更新1 | 2 &#x3D; 3，第二次更新3 | 2 &#x3D; 3。可见值是相同的。<br>听到这种方案后也怀疑效率问题，在1000w数据中统计速度与reg_time中索引时间差不多，所以问题不大；一个整形4个字节32位，可以表示32个不同的留存，整形不够也可以用长整型8个字节的。总体看来该方法可扩展，可重新统计，所以可行。<br>位运算之前只在权限中见过，这里用法也是一种不错的方式，期待更多的思考，下面是位运算的基本操作：</p><img src="/article/3167685568/3167685568/93d58b1b8cb950e860d514b6f4e19ff6.jpg" title="位运算"></div></article><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="/tags/">Tags</a></li><li><a href="/about/">About</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%9C%80%E5%90%8E%E7%99%BB%E5%BD%95%E6%97%B6%E9%97%B4%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">通过最后登录时间实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BB%BA%E7%AB%8B%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">通过建立独立的字段实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">通过位运算实现</span></a></li></ol></div><div id="share-footer" style="display:none"><ul><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://panda843.github.io/article/3167685568.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https://panda843.github.io/article/3167685568.html&text=位运算实现用户留存率"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://panda843.github.io/article/3167685568.html&is_video=false&description=位运算实现用户留存率"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=位运算实现用户留存率&body=Check out this article: https://panda843.github.io/article/3167685568.html"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https://panda843.github.io/article/3167685568.html&title=位运算实现用户留存率"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.tumblr.com/share/link?url=https://panda843.github.io/article/3167685568.html&name=位运算实现用户留存率&description=&lt;p&gt;统计留存率之前先弄清一下留存率的概念，百度百科中是这么说的：&lt;br&gt;用户在某段时间内开始使用应用，经过一段时间后，仍然继续使用应用的被认作是留存；这部分用户占当时新增用户的比例即是留存率，会按照每隔1单位时 间（例日、周、月）来进行统计。顾名思义，留存指的就是“有多少用户留下来了”。留存用户和留存率体现了应用的质量和保留用户的能力。&lt;br&gt;简单点说，第一天新增加了100个用户，第二天这100个人有50个还有登录，第三天这100个人还有30个有登录。。。依次类推&lt;br&gt;那次日留存率为50%，三日留存为30% 。&lt;br&gt;在统计系统中经常需要统计用户留存率，这里整理下用户留存率统计的几种实现方式。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://panda843.github.io/article/3167685568.html&t=位运算实现用户留存率"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a><a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a><a id="share" class="icon" href="#" onclick='return $("#share-footer").toggle(),!1'><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a><a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2016-2024 是潘达呀</div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="/tags/">Tags</a></li><li><a href="/about/">About</a></li></ul></nav></div></footer></div><link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload='this.onload=null,this.rel="stylesheet"'><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script><script>$(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })</script><script src="/js/main.js"></script></body></html>